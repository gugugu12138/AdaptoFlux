[English](README_en.md) | 中文 
# AdaptoFlux

**一种基于功能集（包含多种类型的函数的集合）实现智能的算法**

## 项目概述
AdaptoFlux是一种基于功能集的智能算法。不同于传统的深度学习，该算法通过生成一个基于路径的操作流程，实现智能计算和优化。通过对功能集和坍缩函数的操作，该算法拥有极强的兼容性和较强的可解释性。

## 进展情况
- **模型化简**和**新函数生成**部分仍在开发中。
- 正在编写**基于该算法在不修改MLP模型情况优化 MLP**的示例代码，并持续优化。
- 正在重构ATF部分代码，使用DFG结构

## 未来工作
- 进一步优化模型化简过程，提高计算效率。
- 完善新函数生成机制，以增强算法适用性。
- 完成并优化 MLP 优化示例代码，使其更具参考价值。
- 载入模型后在原模型基础上训练
- 从模型中提取一部分已完成的路径进行重新训练
- 根据不同的输入数据选择不同的功能集进行路径选择，对数据分组选择不同的功能集
- 从当前模型中切除一块路径，记录输入数据点数和输出数据点数，重新训练一个新路径使得输入和输出和原本路径相同，以此进行优化网络
- 加一个功能集装饰器直接定义位置
- 多功能集分别处理不同的数据

# 如何使用
1. 创建新的 conda 环境：

```bash
conda create -n AdaptoFlux python=3.12
conda activate AdaptoFlux
```

2. 克隆仓库：

```bash
git clone https://github.com/gugugu12138/AdaptoFlux.git
cd AdaptoFlux
```

3. 安装依赖：

```bash
pip install -r requirements.txt
```
注: 使用的功能集需要额外配置环境

# 修改功能集
AdaptoFlux的训练和推理基于功能集进行运行，通过修改methods.py中的函数，为AdaptoFlux提供不同的选择，达到更好的效果。
(你甚至可以往功能集里面塞随机森林和MLP模型)

# 数据处理模型结构说明
## 数据流
从输入数据到输出结果的处理过程。数据沿着动态生成的路径逐层进行特征提取和转换，每一层级执行特定的任务，并最终通过 **坍缩函数** 将中间表示转化为目标形式的过程。

## 坍缩函数
可选的转换操作，用于在基于动态生成路径的数据流处理过程中，从路径末端提取经过逐层操作后的数据，并将其转化为具有特定目标格式的输出。  
具体而言，当网络中的某些值与 **指导值** 存在直接关系时，坍缩函数通过聚合或总结操作，将复杂的中间表示简化为更简洁的目标形式。  
其输入可以是单个节点的特征向量，也可以是整个路径末端的综合数据，输出则根据任务需求定制，例如概率分布、类别标签或其他所需格式。
（与功能集同理，坍缩函数可以灵活选择算法，如使用MLP作为坍缩函数）

## 指导值
用于指导神经的生长或退化。

- 指标分类与层级划分：

  | 类别   | 示例指标       | 调整目标      | 影响权重 |
  | ---- | ---------- | --------- | ---- |
  | 核心任务 | 准确率、F1分数   | 直接优化任务性能  | 高（α） |
  | 路径质量 | 路径熵、路径深度   | 保障探索与架构健康 | 中（β） |
  | 计算效率 | 内存占用、FLOPs | 抑制资源浪费    | 低（γ） |
  | 损失控制 | MSE、RMSE、交叉熵 | 训练初期调整优化方向，后期减少影响 | 变（δ）

- **多指标融合公式**

  $$
  指导值 = \sum \omega_i \cdot 核心指标_i + \sum \phi_j \cdot 路径指标_j - \sum \psi_k \cdot 效率指标_k - \delta \cdot 损失值
  $$

- **示例计算公式**：

$$
指导值 = \alpha \cdot 准确率 + \beta \cdot 路径熵 - \gamma \cdot 冗余操作惩罚 - \delta \cdot 损失值
$$

#### 路径熵计算

$$
路径熵 = -\sum P(路径_i) \cdot \log P(路径_i)
$$

其中，$P(路径_{\text{i}})$ 表示第 i 类路径的出现频率（统计窗口内的占比）。

#### 冗余操作惩罚计算

$$
冗余操作惩罚 = \sum (无效计算次数)
$$

## 功能集（Q）
包含多种类型的函数的集合。

## 函数集（F）
只包含映射函数的功能集。

## 操作集（O）
只包含动作函数的功能集。


```math
G = \left\{ g_1, g_2, g_3, \dots, g_n \right\}
```

```math
F = \left\{ f_1, f_2, f_3, \dots, f_m \right\}
```

```math
O = \left\{ o_1, o_2, o_3, \dots, o_k \right\}
```

![基础结构](./assets/images/基础结构图2.0.png)




## 优化逻辑

1. **生成初始模型**
使用process_random_method函数生成多份指定层数的模型（这一部分不进行损失计算）（或结合replace_random_elements一定程度上优化）
对比模型，选择性能最佳的初始模型。
2. **修改初始模型图节点**
对于初始模型中的每一个功能节点，从某个方向的某一层开始，逐个比较可替换的节点（输入输出维度相同的节点），对比修改节点后损失大小，选择性能最佳的节点。重复扫描多次。
3. **生成化简模型**
随机生成输入输出维度与某一部分图相同的模型，对比两者在一定范围内的输入输出，使用性能更好的模型替换图中所有相同的图，重复此流程。
4. **生成新功能集**
训练过程中，将表现优异的部分切块，迭代为新的功能集，一定轮次后使用新功能集。



## 模型处理流程
1. **输入层处理**  
   - 初始数据点数量：n
   - 按照功能集规则随机分组
   - 对每个分组执行对应函数

2. **迭代处理**  
   - 处理后将数据还原并重新分组
   - 重复流程直至到达路径末端

3. **输出生成**  
   - 对尾部数据应用坍缩函数
   - 生成最终网络输出

---

## 数据量变化公式
### 关键参数定义
- `Iₐ`：函数a的输入/输出数据量比
- `H`：每层数据期望减少比例
- `k`：功能集函数总数
- `Wₐ`：函数a的被选概率

**核心公式**  
```math
H = \sum_{i=1}^{k} W_i I_i
```

在不同训练阶段采用不同的功能集进行处理，可以实现对数据的扩维，修改，降维。
从该公式可以发现，通过对随机选取方法的适量修改，可以很简单的控制输入和坍缩层前的维度，对于大部分激活函数都有很强的兼容性。

### 层间数据量关系
- `n₀`：初始数据量
- `L`：模型层数
- `nₗ`：第L层数据量  
```math
n₀ \cdot H^L = n_L
```
---

## 路径化简
对于已经训练得到的的路径，我们可以提取出使用的功能集，生成一个该功能集可用的随机数据列表，
从该数据列表中按照不同长度切割成多个二维列表，将这些二维列表作为数据进行有限制（如限制层数）无监督训练，
将训练出的多个路径做对比，如输入和输出完全相同（或大部分相同），认为该两条路径等效，对它们的指标进行判断（如路径深度，运行速度等），
在原路径中使用更优的路径替换掉原部分

## 函数集特性分析
### 分类定义
| 类型       | 特性                          | 反向推导能力        |
|------------|-------------------------------|---------------------|
| 双射函数集 | 所有函数为双射                | 完全可逆            |
| 单射函数集 | 所有函数为单射                | 可逆（需额外信息）  |
| 满射函数集 | 所有函数为满射                | 多输入对应单输出    |

### 特殊函数集示例
```math
F = \begin{cases}
f_1(a,b) = a \cdot c_1 + b \cdot d_1 \\
f_2(a,b) = a \cdot c_2 + b \cdot d_2 \\
\vdots \\
f_n(a,b) = a \cdot c_n + b \cdot d_n
\end{cases}
```
*条件：任意一组(c,d)互质*

---
## 功能集特性

### 组合路径数量公式

#### **公式定义**
$$
N_{\text{paths}} = \prod_{l=1}^{L} \left( |F|^{n_{l-1}} \right)
$$

其中：
- $N_{\text{paths}}$ ：总路径数量。
- $L$ ：路径的层数（深度）。
- $n_{l-1}$ ：第 $l-1$ 层的数据量（即第 $l$ 层的输入数据量）。
- $|F|$ ：函数集 $F$ 的大小（可选函数数量）。

#### **关键说明**
1. **递归性**：
   - 每一层的路径选择取决于前一层的输出数据量 $n_{l-1}$ 。
   - 每个数据点独立选择函数，因此每层的路径分支数为 $|F|^{n_{l-1}}$ 。

2. **示例验证**：
   - **案例1**：1层1数据，2函数  
     $N_{\text{paths}} = 2^1 = 2$ （符合：路径为 $f_1$ 或 $f_2$ ）。
   - **案例2**：2层1数据，2函数  
     $N_{\text{paths}} = 2^1 \times 2^1 = 4$（每层2种选择，组合为4）。
   - **案例3**：2层2数据，2函数  
     $N_{\text{paths}} = 2^2 \times 2^2 = 16$（第一层4种，第二层4种，组合为16）。

3. **动态数据量扩展**：
   - 若函数可能改变数据量（如 $n_l \neq n_{l-1}$ ），需额外定义 $n_l$ 的更新规则（如 $n_l = \sum_{i=1}^{n_{l-1}} \dim_\text{out}(f_i)$
 ）。

#### **完整定义**
1. **输入**：
   - 初始数据量 $n_0$ 。
   - 函数集 $F = \{f_1, f_2, \dots, f_m\}$ 。
   - 路径深度 $L$ 。

2. **输出**：
   - 总路径数量 $N_{\text{paths}}$ 。

3. **约束条件**：
   - 所有函数输入/输出数据量为1（默认情况下）。若函数支持多输入输出，需调整公式为：

```math
N_{\text{paths}} = \prod_{l=1}^{L} \left( |F|^{n_{l-1}} \times \prod_{i=1}^{n_{l-1}} \dim_\text{out}(f_i) \right)
```

#### **示例计算**

##### **问题设定**

* **初始数据量**：
  $n_0 = 2$（两个独立的数据点）

* **函数集**：
  $F = \{f_1, f_2\}$，每个函数：

  * 输入：1个数据
  * 输出：2个数据

* **层数**：2层

---

##### **分步计算**

###### **第1层（$l=1$）**

* **输入数据量**：
  $n_0 = 2$

* **每个数据点选择函数**：

  * 数据点1可选 $f_1$ 或 $f_2$（2种）
  * 数据点2可选 $f_1$ 或 $f_2$（2种）

* **分支数**：
  $2 \times 2 = 4$

* **输出数据量**：
  每个函数输出2个数据 → 每处理1个输入，生成2个输出。
  $n_1 = 2 \times 2 = 4$

##### **第2层（$l=2$）**

* **输入数据量**：
  $n_1 = 4$

* **每个数据点选择函数**：
  每个数据点有2种选择（$f_1$ 或 $f_2$）

* **分支数**：
  $2^4 = 16$

* **输出数据量（可选）**：
  $n_2 = 4 \times 2 = 8$（可继续但不影响路径数）

---

##### **总路径数**

* 第1层分支数：4
* 第2层分支数：16

$$
\text{总路径数} = 4 \times 16 = 64
$$

---

##### **验证枚举**

###### **第1层的4种选择**

1. $(f_1, f_1)$
2. $(f_1, f_2)$
3. $(f_2, f_1)$
4. $(f_2, f_2)$

###### **每种第1层选择对应第2层的16种组合**

以第1层选择 $(f_1, f_1)$ 为例：

* **输出数据量**：
  $2 \times 2 = 4$

* **第2层选择组合数**：
  $2^4 = 16$

例如：
$(f_1, f_1, f_1, f_1)$,
$(f_1, f_1, f_1, f_2)$,
...
$(f_2, f_2, f_2, f_2)$

总路径数仍为：

$$
4 \times 16 = 64
$$

---

##### **一般化公式匹配**

根据一般公式：

$$
N_{\text{paths}} = \prod_{l=1}^{L} |F|^{n_{l-1}}
$$

* 第1层：
  $|F|^{n_0} = 2^2 = 4$

* 第2层：
  $|F|^{n_1} = 2^4 = 16$

* **总路径数**：
  $4 \times 16 = 64$

与枚举结果一致 ✅

---

### 函数组合的特征维度演化

#### 定义

**背景**
假设我们有一个非常简化的模型，它由两个层次组成（ $L=2$ ），并且每一层都包含两种不同的函数组合方式。每个函数组合接受一定的输入并产生输出。我们的目标是计算整个模型的解空间维度和总解空间维度。

##### 层次1

- **组合A**: 输入维度为 2，输出维度为 3。
- **组合B**: 输入维度为 2，输出维度为 4。

##### 层次2

- **组合C**: 输入维度为 3，输出维度为 5。
- **组合D**: 输入维度为 4，输出维度为 6。

初始输入维度为 2。

##### 解空间

**解空间** 是该算法能够探索的所有**非等效 DFG 图所生成的输出结果的集合**。

每个 DFG 图代表一种函数组合路径，但只有当其输出与其他图不同时，才被视为一个新的“解”。

**示例**

在给定的例子中，有四种可能的路径组合：

1. A → C  
2. A → D  
3. B → C  
4. B → D  

我们运行这些路径后得到它们的输出结果，设为：

- 输出1： $o_1$
- 输出2： $o_2$
- 输出3： $o_1$ （与第一条路径等效）
- 输出4： $o_3$

那么实际的**非等效输出集合**为：

```math
\mathcal{O} = \left\{o_1, o_2, o_3 \right\}
```

因此，解空间的大小为：

```math
|\mathcal{S}| = |\left\{o_1, o_2, o_3 \right\}| = 3
```

###### 公式化描述

**解空间定义公式**  

```math
\mathcal{S} = \left\{ f(p) \mid p \in \mathcal{P} \right\}
```

**解空间大小公式**  

$$
|\mathcal{S}| = \left| \bigcup_{p \in \mathcal{P}} \{f(p)\} \right|
$$

也可以写作：

$$
|\mathcal{S}| = |\mathcal{P}| - \sum_{i=1}^{k}(n_i - 1)
$$

其中：
- $\mathcal{P}$ ：所有路径组合构成的集合， $\mathcal{P} = \{p_1, p_2, ..., p_N\}$
- $f(p_i)$ ：路径 $p_i$ 对应的输出结果（可以是向量、哈希值或某种特征表示）
- $|\mathcal{P}|$ ：总路径数；
- $k$ ：等效类的数量（即不同输出的数量）；
- $n_i$ ：第 $i$ 个等效类包含的路径数（满足 $\sum n_i = |\mathcal{P}|$ ）

##### 解空间维度

**定义**: 解空间维度指的是每一层上解空间的复杂度，即每层的数据特征数量或信息量。对于每一层，我们需要考虑所有可能的组合方式，并确定其输出维度。

**示例**: 
- **第一层**: 组合A的输出维度为3，组合B的输出维度为4。因此，第一层的解空间维度为{3, 4}，意味着第一层可以产生3维或4维的输出。
- **第二层**: 
  - 如果第一层选择了组合A（输出维度为3），则只能选择组合C（输出维度为5）。
  - 如果第一层选择了组合B（输出维度为4），则可以选择组合D（输出维度为6）。
  
因此，第二层的解空间维度取决于前一层的选择，分别为{5}和{6}。



**动态维度传播公式**
```math
\text{dim}(\mathcal{S}_Q^{(L)}) = \sum_{f_i \in Q} \text{dim}_{\text{out}}(f_i) \cdot \mathbb{I}\left[\text{dim}_{\text{in}}(f_i) = \text{dim}(\mathcal{S}_Q^{(L-1)})\right]
```
其中：
- `L` 为当前层数，`dim(S_Q^(0))` 为初始输入维度。
- `dim_in(f_i)` 和 `dim_out(f_i)` 分别表示函数 `f_i` 的输入/输出维度。
- `𝕀[⋅]` 为指示函数，确保维度匹配。


**总解空间维度**：
```math
\text{dim}(\mathcal{S}_Q) = \sum_{L=1}^{d} \text{dim}(\mathcal{S}_Q^{(L)})
```

**类型系统扩展**
引入类型约束：
- 为每个函数定义输入/输出类型签名（如 `f_i: T₁ → T₂`）。
- 仅当类型匹配时，函数可被组合。例如：
  - 若 `f1` 输出类型为 `Matrix`，而 `f2` 输入类型为 `Vector`，则二者不可直接组合。

**通用公式（综合维度与类型）**
```math
\text{dim}(\mathcal{S}_Q) = \sum_{L=1}^{d} \left( \prod_{k=1}^{L} \sum_{f_i \in Q} \text{dim}_{\text{out}}(f_i) \cdot \mathbb{I}\left[\text{type}_{\text{out}}(f_i^{(k-1)}) = \text{type}_{\text{in}}(f_i)\right] \right)
```

```math
\text{dim}(\mathcal{S}_Q) = \sum_{k=1}^{d} \left( \prod_{f_i \in Q} \text{dim}(\mathcal{M}_i) \right)^k
```

```math
\text{dim}(\mathcal{M}_i) = R_{\text{in}}(i) \times R_{\text{out}}(i)
```

**约束**：
```math
当 F_{\text{完备}} \not\subseteq Q 时，\text{dim}(\mathcal{S}_Q) = 0 （无法覆盖解空间）
```

其中：
- $\mathcal{M}_i$ 表示函数 $f_i$ 的映射空间
- $\mathcal{S}_Q$ 表示功能集 $Q$ 能覆盖的解空间；
- $d$ 为最大组合深度（即函数组合的最大层数）；
- $Q_k$ 表示第 $k$ 层中使用的函数子集；
- $R_{\text{in}}(i)$ 表示函数 $f_i$ 的输入维度；
- $R_{\text{out}}(i)$ 表示函数 $f_i$ 的输出维度。

#### 解释：

- **广度**：每个函数的输入输出维度决定了解空间的“基底维度”，即一次性调用所有函数时的表达能力。
- **深度**：函数的多层组合显著扩展了解空间的覆盖能力，形成更复杂的组合结构。
- **总维度**：在每一层中，所有函数输入输出的乘积形成该层的维度贡献，所有层的贡献总和即为整个解空间的维度估计。

> 如果统一了所有函数的输入输出维度（如标准化为向量维度 $R$），该公式可进一步简化为：
>
> $$
> \text{dim}(\mathcal{S}_Q) \propto d \cdot R^{2 \cdot |Q|}
> $$

---

### 功能集求解效率与完备性关系

#### 定义
- **功能集完备性（C）**: 表示功能集Q与最小必要函数集 $F_{\text{完备}}$ 的接近程度，定义为：

$$
C(Q) = 1 - \frac{|Q| - |F_{\text{完备}}|}{|Q|}
$$

其中， $F_{\text{完备}}$ 是解决目标问题所需的最小完备函数集，|Q| 是功能集Q的大小。

- **有效完备性**

```math
C_{\text{eff}}(Q) = \frac{\sum_{f_i \in F_{\text{完备}}} \text{dim}(\mathcal{M}_i)}{\sum_{f_j \in Q} \text{dim}(\mathcal{M}_j)} \times \left(1 - \frac{|Q| - |F_{\text{完备}}|}{|Q|}\right)
```

- **第一项**：原始完备性比率
- **第二项**：关键函数维度权重

$$ 
C_{\text{eff}} \in (0,1] 
$$

- **性质**：冗余低维函数会显著降低该值

- **求解效率（E）**: 在功能集Q中找到能解决目标问题的有效路径的平均速度，与以下因素相关：
  - 路径搜索的收敛速度
  - 功能集的探索效率
  - 无效路径的排除速度

#### 效率公式
当功能集Q能够解决目标问题时，其求解效率（E）与完备性（C）的关系可以表示为：

```math
E(Q) = \frac{\beta(Q)}{\text{dim}(\mathcal{S}_Q)^{1/\gamma}} \times \frac{1}{C_{\text{eff}}(Q)^\alpha + \eta}
```

其中：
- `α > 0` 是完备性影响系数
- `η` 是路径探索效率常数（与功能集结构相关）
- $\beta(Q) = \frac{\text{平均路径质量}}{\text{最大路径质量}}$（衡量函数组合有效性）
- $\gamma$ 为维度衰减系数

#### 解释
- **完备性越高（C越大）**：
  - ✅ 路径搜索空间更集中
  - ✅ 无效组合更少
  - ❌ 可能遗漏最优解

- **完备性越低（C越小）**：
  - ✅ 解空间更完整
  - ❌ 需要更多探索时间
  - ❌ 冗余计算增加


#### 约束条件
功能集Q必须满足：

$$
F_{\text{完备}} \subseteq Q
$$

即功能集Q至少包含解决目标问题所需的最小完备函数集。

---

### 全局最优概率

当功能集 $Q$ 包含的函数越多，其包含全局最优解组合的可能性也越高。公式如下：

```math
P(\text{全局最优}) = P_{\text{cover}} \cdot P_{\text{hit}}
```

#### **1. 覆盖性概率 $P_{\text{cover}}$**
- **定义**： $Q$ 的函数组合能否构造出全局最优解对应的路径。 
- **公式**：  
  - 若 $F_{\text{完备}} \subseteq Q$，则 $P_{\text{cover}} = 1$（完备性保证）。  
  - 否则， $P_{\text{cover}} = 0$ （无法覆盖）。   

- $N$ 为搜索次数
- 当 $Q=F_{\text{完备}}$ 时概率最高（无冗余干扰）
- $|Q|$：当前功能集大小  
- $|F_{\text{完备}}|$：解决目标问题所需的最小完备函数集大小  
- **含义**：功能集越大，相对包含完备子集的概率越高，从而提升找到最优解的机会。

#### **2. 搜索命中概率 $P_{\text{hit}}$**
即使 $P_{\text{cover}} = 1$，实际命中概率取决于：
- **路径生成策略**（如随机搜索、启发式规则）。  
- **资源限制**（搜索次数 $N$、最大路径深度 $d$）。  

**公式**：
```math
P_{\text{hit}} = 1 - \left(1 - \frac{1}{M}\right)^N
```

- $M$：所有可能的有效路径数量（受限于深度和函数组合规则）。 若多条路径对应同一解需对M去重计算
- $N$：搜索次数。  

---

### **案例对比**
#### 情况1： $Q = F_{\text{完备}}$（最小完备集）
- $P_{\text{cover}} = 1$。  
- 假设深度 $d=3$ 时，可能的路径数 $M=10$，搜索 $N=5$ 次：  
```math
P = 1 \cdot \left(1 - \left(1 - \frac{1}{10}\right)^5\right) \approx 0.41
```
  **并非 100%**，因为有限的 $N$ 和 $M$。

#### 情况2： $Q \supset F_{\text{完备}}$（含冗余）
- $P_{\text{cover}} = 1$。  
- 冗余使 $M=100$，相同 $N=5$：  
```math
P = 1 \cdot \left(1 - \left(1 - \frac{1}{100}\right)^5\right) \approx 0.05
```
  **概率显著降低**，因冗余扩大了搜索空间。

---

### 抗过拟合能力

完备性较低的功能集具有更强的泛化能力，对应的过拟合风险为：

公式一：

```math
\mathcal{L}_{\text{generalize}} = \eta \left[ \frac{1}{\sqrt{C_{\text{eff}}(Q)}} + \lambda \cdot \text{dim}(\mathcal{S}_Q) \right]
```
- $\lambda$ 为平衡系数
- $\mathcal{L}_{\text{generalize}}$：过拟合风险
- $\eta$：常数项，表示任务复杂度或样本扰动影响  
- **含义**：完备性越低（覆盖越全面），模型越不容易过拟合特定样本，具备更好的泛化能力。

公式二：

```math
\mathcal{L}_{\text{generalize}} = \frac{\eta}{\sqrt{C_{\text{eff}}(Q)}}
```

```math
\eta = \eta_0 \cdot (1 + \xi \cdot (1 - C_{\text{eff}}(Q)))
```
**物理意义**：
- 当 $C_{\text{eff}} \to 1$（高完备性）：
  - 过拟合风险最小，但可能过滤掉非常规解（ $\xi$  项趋近0）
- 当 $C_{\text{eff}} \to 0$（低完备性）：
  - 过拟合风险最大，但保留发现特殊解的可能性（ $\xi$  项放大）

---

### **示例（综合对比）**
该部分数据计算主要由ai完成，不保真
#### 假设条件
- **最小完备集**：  
  $$F_{\text{完备}} = \{f_1, f_2\}, \quad \text{dim}(\mathcal{M}_1)=4, \text{dim}(\mathcal{M}_2)=9$$  
- **其他函数**： $\text{dim}(\mathcal{M}_i)=1$（低维冗余）， $\text{dim}(\mathcal{M}_6)=5$ （高维冗余）  
- **参数**：  
  - 搜索参数： $d=2, N=10$  
  - 效率参数： $\alpha=\gamma=2, \eta=0.1, \beta=0.8$  
  - 泛化参数： $\lambda=0.01, \xi=0.5, \eta_0=0.1$  

#### 对比功能集
| 指标                  | Q₁ = {f₁,f₂,f₃}               | Q₂ = {f₁,f₂,f₃,f₄,f₅}         | Q₃ = {f₁,f₂,f₆}               |
|-----------------------|-------------------------------|-------------------------------|------------------------------|
| **有效完备性 $C_{\text{eff}}$** | 0.62                          | 0.33                          | 0.58                          |
| **解空间维度 $\text{dim}(\mathcal{S}_Q)$** | 1332                          | 1332                          | 1332                         |
| **求解效率 $E(Q)$**   | 0.05                          | 0.02                          | 0.04                          |
| **全局最优概率 $P$**  | 0.65                          | 0.18                          | 0.57                          |
| **泛化误差 $\mathcal{L}_1$**（公式一） | 1.38                          | 1.48                          | 1.40                          |
| **泛化误差 $\mathcal{L}_2$**（公式二） | 0.14                          | 0.25                          | 0.15                          |

#### 计算公式与注释
1. **求解效率**（保留原公式）：
```math  
E(Q) = \frac{\beta}{\text{dim}(\mathcal{S}_Q)^{1/\gamma}} \cdot \frac{1}{C_{\text{eff}}(Q)^\alpha + \eta}
```  
   - *物理意义*：效率随完备性提升而降低，随解空间维度增加而降低。  

2. **全局最优概率**（分阶段计算）：  
```math
P = P_{\text{cover}} \cdot \left(1 - \left(1 - \frac{1}{M}\right)^N \right)
```
   - *参数*： $M=10$（Q₁/Q₃）、 $M=50$ （Q₂） , $P_{\text{cover}}=1$（因 $F_{\text{完备}} \subseteq Q$ ）。  

3. **泛化误差公式一**（惩罚低完备性+高维度）：  
```math
\mathcal{L}_1 = \eta \left[ \frac{1}{\sqrt{C_{\text{eff}}(Q)}} + \lambda \cdot \text{dim}(\mathcal{S}_Q) \right]
``` 
   - *特点*：受解空间维度主导，Q₁/Q₂/Q₃差异较小（因 $\text{dim}(\mathcal{S}_Q)$ 相同）。  

4. **泛化误差公式二**（仅依赖完备性）：  
```math
\mathcal{L}_2 = \frac{\eta_0 \cdot (1 + \xi \cdot (1 - C_{\text{eff}}(Q)))}{\sqrt{C_{\text{eff}}(Q)}}
```

   - *特点*：对 $C_{\text{eff}}$ 变化更敏感，Q₂误差比Q₁高78%。  

---

### **关键结论**
1. **冗余数量的负面影响**（对比Q₁与Q₂）：  
   - **Q₂**（5函数含3低维冗余）：  
     - 有效完备性最低（ $C_{\text{eff}}=0.33$ ），导致效率（ $E=0.02$ ）、最优概率（ $P=0.18$ ）、泛化性（ $\mathcal{L}_2=0.25$ ）全面劣化。  
   - **Q₁**（3函数含1低维冗余）：  
     - 各项指标均优于Q₂，尤其是泛化误差降低44%。  

2. **冗余维度的差异化影响**（对比Q₁与Q₃）：  
   - **Q₃**（高维冗余 $f_6$ ）：  
```math
因 \text{dim}(\mathcal{M}_6)=5 , C_{\text{eff}} 略低于Q₁（0.58 vs 0.62）,但效率和泛化性接近。  
```
  说明**高维冗余对性能的损害小于低维冗余**。  

3. **公式选择建议**：  
   - 若关注**理论解空间**：使用公式一（含 $\text{dim}(\mathcal{S}_Q)$ 项）。  
   - 若关注**实际泛化能力**：使用公式二（纯完备性驱动）。  

---

### **示例对应的计算过程**
#### 1. 求解效率计算（以Q₁为例）
$$
E(Q_1) = \frac{0.8}{\sqrt{1332}} \cdot \frac{1}{0.62^2 + 0.1} \approx \frac{0.8}{36.5} \cdot \frac{1}{0.48} \approx 0.05
$$

#### 2. 泛化误差公式一（以Q₂为例）
$$
\mathcal{L}_1 = 0.1 \left( \frac{1}{\sqrt{0.33}} + 0.01 \times 1332 \right) \approx 0.1 \left( 1.74 + 13.32 \right) \approx 1.48
$$

#### 3. 泛化误差公式二（以Q₃为例）
$$
\mathcal{L}_2 = \frac{0.1 \cdot (1 + 0.5 \times 0.42)}{\sqrt{0.58}} \approx \frac{0.121}{0.76} \approx 0.15
$$

---

#### 泛化性与完备性的关系
1. **完备性越低**：  
   - 功能集覆盖的解空间更接近真实数据分布，减少过拟合风险。  
   - 公式二中， $C_{\text{eff}} \to 1$ 时， $\mathcal{L}_{\text{generalize}} \approx \eta_0$ （理论下限）。  

2. **冗余函数的双重影响**：  
   - **负面**：降低 $C_{\text{eff}}$ ，增加泛化误差。  
   - **正面**：可能提供非常规解路径，适合探索性任务。  

3. **实践平衡**：  
   - 分类任务：追求高 $C_{\text{eff}}$ （如Q₁）。  
   - 生成任务：可容忍低 $C_{\text{eff}}$ （如Q₃），保留创新性路径。  

---


## 应用特性
### 满射函数集特性
- **输入空间增长公式**  
  ```math
  T = R^C
  ```
  - `T`：输入空间大小
  - `R`：函数输入数量均值
  - `C`：函数调用总次数

### 加密与压缩应用
- 通过添加随机变量实现单射转换
- 支持输出到唯一输入的映射



### 对无直接输入数据时
当没有直接输入时，可以通过使用一个操作集作为功能集，我们可以使用一个周期信号作为输入，通过操作集中的动作函数组合获取数据（或者使得指导函数趋向目标），以此来实现模型的构建。  

**（这部分理论可行，之后会把图和完整概念放上来）**

---

### 已知的问题
